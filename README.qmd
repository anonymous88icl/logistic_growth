---
title: "Logistic Growth"
format: gfm
---

The first three Questions are explored in this Markdown File developed using Quarto.

---

# Question 1

## Plotting Data

Throughout the project, we are using data from `experiment.csv`. We start our analysis by considering the standard Time vs Population plot and the semi-log transformed Time vs Population plot (Population axis transformed), generated by the following script (`plot_data.R`):

```{r}
#| warning: false

growth_data <- read.csv("experiment.csv")

install.packages("ggplot2")
library(ggplot2)

#Standard Time vs Population Plot
ggplot(aes(t,N), data = growth_data) +
  
  geom_point() +
  
  xlab("t") +
  
  ylab("y") +
  
  theme_bw()


#Semi-log plot
ggplot(aes(t,N), data = growth_data) +
  
  geom_point() +
  
  xlab("t") +
  
  ylab("y") +
  
  scale_y_continuous(trans='log10')

```
Since both plots are very sensitive to scale (it is very hard to see deviations in the points on the extremes), we include interactive versions of both plots at [].

## Fitting Linear Models

It is easy (especially with the interactive plots) to notice that in the first plot, the beginning (t < 1500) is very similar to an exponential function and the ending (t > 2500) is very similar to a constant function. Equivalently, the second plot has an increasing linear beginning and a constant ending. 

This motivates a simple approach to fit a logistic function, by fitting the linear and constant portions separately, then we evaluate various statistics in the context of linear models. By doing a grid search (intervals of 50) on boundary values and comparing t-values (p-values have became too low), I determined that t < 1550 and t > 4000 would be the way to split that gave the most accurate results.

If we wanted to improve reproducibility or flexibility to different datasets, a better idea would be to do a logistic regression directly instead of manually identifying suitable bounds. 

Now we present the code used to fit the data (`fit_linear_model.R`):
```{r}
#| warning: false
#| results: hide
#Script to estimate the model parameters using a linear approximation

install.packages("dplyr")
library(dplyr)

#We assume the programs are run in series -- no need to re-read the data file
#growth_data <- read.csv("experiment.csv")


#This is not actually a great way to do the fitting, since it is not very reusable
#   (for example, if we change the data). A better way would be to do a logistic 
#   regression directly by minimizing squared loss, but that would require
#   numerical optimization techniques.
#Case 1. K >> N0, t is small

data_subset1 <- growth_data %>% filter(t<1550) %>% mutate(N_log = log(N))

model1 <- lm(N_log ~ t, data_subset1)
#Case 2. N(t) = K

data_subset2 <- growth_data %>% filter(t>4000)

model2 <- lm(N ~ 1, data_subset2)

```

We can use the following code (included in the actual code) to inspect the model and its statistics:

```{r}
summary(model1)
summary(model2)
```
We are happy with these results. Now we will plot them with our original data.

## Plotting the Models

We extract the coefficients directly from "model1" and "model2" (instead of inspecting the coefficients), improving reproducibility and flexibility of the program. The following is the code for both the logistic and semi-log plots. (`plot_data_and_model.R`)

```{r}
#Script to plot data and model

#growth_data <- read.csv("experiment.csv")

logistic_fun <- function(t) {
  
  N <- (N0*K*exp(r*t))/(K-N0+N0*exp(r*t))
  
  return(N)
  
}
#This increases flexibility/mutability
N0 <- exp(coef(model1)[1]) #
  
r <- coef(model1)[2] #
  
K <- coef(model2)[1] #

ggplot(aes(t,N), data = growth_data) +
  
  geom_function(fun=logistic_fun, colour="red") +
  
  geom_point()

  #scale_y_continuous(trans='log10')


ggplot(aes(t,N), data = growth_data) +
  
  geom_function(fun=logistic_fun, colour="red") +
  
  geom_point() +

  scale_y_continuous(trans='log10')



```

## Results

Here we present the results given by the summary() functions. We consider the linear and constant portions seperately.

### Case 1: $K >> N_0$, $t < 1550$ (linear)

IN this case, the logistic function is very similar to an exponential function. After the transformation, the function we are fitting is approximately $\log(N_0\cdot{e^{rt}}) = \log({N_0}) + r\cdot{t}$. The coefficients given by `summary(model1)` are:
$$
\log({N_0}) = 6.898
$$
$$
r = 0.01
$$
And hence

$$
N_0 = \exp(6.898) = 990
$$

### Case 2: $t > 4000$

In this case, the function becomes near constant. Here, `summary(model2)` gives us a good approximation to the value:
$$
K = 6.00\cdot10^{10}
$$

---

# Question 2

The exponential function given by fitting when $t < 1550$ is
$$
F(t) = N_0\cdot{e^{rt}}
$$
Hence, the population at $t = 4980$ given by the exponential function is:
$$
F(4980) = 990\cdot{e^{0.01\cdot{4980}}} = 4.20\cdot10^{24}
$$
The logistic funtion, is given by
$$
N(t) = \frac{KN_0e^{rt}}{K-N_0+N_0e^{rt}}
$$
Hence,
$$
N(4980) = \frac{6.00\cdot{10^{10}}\cdot{990}\cdot{e^{0.01\cdot{4980}}}}{6.00\cdot{10^{10}}-990+990\cdot{e^{0.01\cdot{4980}}}} = 6.00\cdot{10^{10}}
$$
Which is expected as $t = 4980$ is on the "constant" portion of the graph and so will be extremely close to $K$.

The difference between the two approximations is:

$$
\frac{F(4980)}{N(4980)} = 7.00\cdot{10^{13}}
$$
As we can see, the exponential model becomes many orders larger than the logistic model when t is large.
---

# Question 3

As with before, most of the plots are quite scale-sensitive, so we will include an interactive version of each plot too. Once again, we assume this script will be run after the previous scripts have, so all variables will be defined already. We will have one direct comparison of the exact functions and one which is semi-log transformed. For the first plot, we will only show a snippet for $N_0 < \text{Population Size} < 3\cdot{K}$ to deal with scale differences. The second plot is more informative.

Here is the code that produces the non-interactive plots (`logistic_vs_exponential_plots.R`):
```{r}
#| warning: false
#Definition of exponential function
exponential_fun <- function(t) {
  
  Nt <- N0*exp(r*t)
  
  return(Nt)
  
}

#For Scale reasons, we only show the plot between N0 < Population_Size < 3*K Refer to the interactive version for the full plot.
ggplot() +
  
  geom_function(aes(color = "Logistic Growth"), fun=logistic_fun) +
  
  geom_function(aes(color = "Exponential Growth"), fun=exponential_fun) +
  
  xlim(0, 5000) +
  
  ylim(N0, 3*K) +
  
  xlab("Time (minutes)") +
  
  ylab("Population Size") +
  
  ggtitle("Logistic vs Exponential Graphs") +
  
  scale_color_manual(values = c("Logistic Growth" = "red", 
                                "Exponential Growth" = "black")) +
  
  theme(plot.title = element_text(hjust = 0.5),
        legend.title = element_blank(),  
        legend.position = "bottom") +
  
  geom_point()

#The Semi-Log plot comparison is better for Comparison

ggplot() +
  
  geom_function(aes(color = "Logistic Growth"), fun=logistic_fun) +
  
  geom_function(aes(color = "Exponential Growth"), fun=exponential_fun) +
  
  xlim(0, 5000) +
  
  scale_y_continuous(trans='log10') + 
  
  xlab("Time (minutes)") +
  
  ylab("Population Size") +
  
  ggtitle("Logistic vs Exponential Graphs (Semi-log scaled)") +
  
  scale_color_manual(values = c("Logistic Growth" = "red", 
                                "Exponential Growth" = "black")) +
  
  theme(plot.title = element_text(hjust = 0.5),
        legend.title = element_blank(),  
        legend.position = "bottom") +
  
  geom_point()




```

Interactive plots can be found here: []
---

